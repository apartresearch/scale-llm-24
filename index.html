<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Workshop on the Scaling Behavior of Large Language Models</title>

    <!-- Setup all meta-information like description and titles -->
    <meta
      name="description"
      content="The workshop on the scaling behavior of large language models invites researchers to submit projects that uncover scaling laws, with a specific foucs on inverse scaling laws, in large language models."
    />
    <meta
      name="keywords"
      content="Scaling laws, mechanistic interpretability, workshop"
    />
    <meta name="author" content="Scaling laws workshop 2024" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <!-- Load fonts Gothic A1 -->
    <link
      href="https://fonts.googleapis.com/css?family=Gothic+A1:400,700&display=swap"
      rel="stylesheet"
    />

    <!-- Load style.css -->
    <link rel="stylesheet" href="style.css" />
  </head>
  <body>
    <!-- Header with a background color filling approx. 300px and that has a title of the workshop and the date as a byline -->
    <header>
      <h1 class="fade-in">Workshop on the Scaling Behavior of Large Language Models</h1>
      <p class="fade-in">Date</p>
    </header>
    <!-- Content on white background with sections Overview, Schedule, Speakers and Organizing Committee -->
    <main class="fade-in">
      <section class="markdown">
## Introduction

Neural Language Models generally seem to adhere
to positive scaling laws: increasing the model size
(in terms of the number of parameters, training data
and training compute) predictably reduces tokenprediction
training loss, which in turn is a good predictor
of performance in many downstream tasks
(Kaplan et al., 2020; Hernandez et al., 2021; Hoffmann
et al., 2022; Nijkamp et al., 2022). This
scaling behavior has lead to Large Language Models
(LLMs) becoming the dominant paradigm in
Natural Language Processing, prompting speculations
about all tasks becoming eventually solved
by sufficiently large models. Sutton (2019) has
called this the "Bitter Lesson" of AI research: simple
models at scale tend to outperform attempts to
implement more complex algorithms that reflect
mental models of how we solve problems.

However, not all tasks follow these scaling
laws. Some show Inverse Scaling, i.e., the performance
drops with increasing model size, or a
non-monotonic pattern such as U-shaped Scaling
and Inverse U-shaped Scaling. Cases that defy
the general trend of positive scaling include several
of the BIG-Bench (Srivastava et al., 2022)
benchmark tasks (several with non-monotonic scaling
and some social bias tasks with inverse scaling,
the latter also previously reported by Parrish
et al. (2022)), unwanted memorization (Carlini
et al., 2023), incorrect Python code generation under
out-of-distribution (OOD) identifier redefinition
(Miceli Barone et al., 2023), poor OOD compositional
generalization of LLMs on a sematic parsing
task (Kim et al., 2022), truthfulness of LLMs
on an adversarial question answering dataset (Lin
et al., 2022), LLM sensitivity to changes to the
prompting format (Perez et al., 2021), etc. These
research efforts, among others, culminated in the
Inverse Scaling Prize (McKenzie et al., 2023) encouraging
the community to contribute and systematically
evaluate new tasks for different LLMs
families. This led to the discovery and characterization
of several types of tasks with inverse or
non-monotonic scaling behaviors.

We believe that studying the scaling behavior
of LLMs is of paramount importance in order to
discover the trajectory of progress in NLP and AI.
Determining whether and to what extent progress
is due to investment in data and compute instead of
traditional research (e.g., on different architectures
and paradigms) can help the scientific community
identify promising areas of research and inform the
expectations of general public and decision makers.
This is especially crucial now, when concerns
about AI safety and its impact on society are becoming
increasingly salient in the public discourse.
We notice that without a central venue dedicated to
promoting and sharing research on this topic, it has
been mainly published on arXiv and promoted on
social media, and much less commonly presented
at peer-reviewed NLP and ML conferences and
workshops. Our workshop aims to promote this
research by providing such venue, establishing a
place for the community to share their results and
discuss the state of the art in this quickly developing
field. While the original Inverse Scaling Prize
was highly successful, it had limitations stemming
from the need to be able to run automatic evaluations
on all the submitted entries hence supporting
only a handful of entry formats and evaluation
metrics. As a result, the challenge ignored generation
tasks, adaptive prompting strategies such as
Chain-of-Thought (Wei et al., 2023), Least-to-Most
(Zhou et al., 2023) or Tree-of-Thoughts (Yao et al.,
2023a), use of external tools (Yao et al., 2023b;
Schick et al., 2023; Qin et al., 2023), among others.
Moreover, the prize only considered fixed model
families and did not allow custom or fine-tuned
models. Our aim is to elicit paper submissions not
constrained to a fixed experimental format, allowing
the authors to choose the task types, model
families, prompting strategies and evaluation metrics
that they deem more appropriate. We also
encourage submissions on studies on internal aspects
of LLMs in relation with scale, such as attribution
(Voita et al., 2021; Ferrando et al., 2023),
mechanistic interpretation (Elhage et al. (2021);
Wang et al. (2022), to name a few), modularity in
computation (Csord√°s et al., 2021; Lepori et al.,
2023), as well as research on deployment-critical
metrics other than SoTA accuracy on benchmarks
(e.g. uncertainty, effectiveness of pruning (Frantar
and Alistarh, 2023; Sun et al., 2023), distillation,
quantization (Dettmers et al., 2022; Dettmers and
Zettlemoyer, 2023), etc.).

## Main Workshop Topics

The workshop will provide focused discussions
on multiple topics in the general field of Scaling
behavior of Large Language Models, including, but
not limited to the following:

1. Novel tasks that exhibit Inverse, U-shaped,
Inverse U-shaped or other types of scaling;
2. Scaling behavior of fine-tuned or purposebuilt
models, in particular in-distribution
(w.r.t. the fine-tuning dataset) vs. out-ofdistribution;
3. Scaling with adaptive prompting strategies,
e.g. allowing intermediate "reasoning" steps,
model self-critique or use of external tools;
4. Scaling w.r.t. additional dimensions, such as
the number of in-context/fine-tuning examples,
the number of "reasoning" steps, or the
intrinsic task complexity;
5. Scaling on non-English language tasks, in particular
low-resource languages, where models
might exhibit tradeoffs as high-resource language
training data overwhelms low-resource
language capabilities;
6. Scaling w.r.t. qualitative characteristics: internal
aspects (e.g. modularity, mechanistic
interpretability), calibration, uncertainty, effectiveness
of various techniques (pruning, defences
against adversarial attacks, etc.).

## Workshop Format

We accept short and long paper submissions with
no more than 4 and 8 pages, respectively, and an
optional 4-page supplementary material. We plan
to host at least one keynote talk, a few oral presentations
and poster sessions during one day, as well
as a panel discussion with 4-5 speakers.

## Invited Talk

Najoung Kim will give a keynote talk. Dr. Kim is an Assistant
Professor at Boston University and a researcher at
Google. She is one of the authors of the Inverse
Scaling Prize paper as well as other foundational
works in this field.
      </section>
      <section>
        <h2>Invited Speakers</h2>
        <div class="speakers">
          <div class="speaker">
            <img src="https://najoung.kim/assets/img/2022_pic.png" alt="Speaker" />
            <div>
              <h3><a href="https://najoung.kim/">Najoung Kim</a></h3>
              <p>Assistant Professor at Boston University</p>
            </div>
          </div>
      </section>
      <section class="markdown">
## Schedule

To be decided
      </section>
      <section>
        <h2>Organizing Committee</h2>
        <div class="organizers">
          <div class="Organizer">
            <img src="https://homepages.inf.ed.ac.uk/amiceli/pic.jpg" alt="Antonio Valerio Miceli-Barone" />
            <div>
              <h3><a href="https://homepages.inf.ed.ac.uk/amiceli/">Antonio Valerio Miceli-Barone</a></h3>
              <p>Research Fellow, University of Edinburgh</p>
            </div>
          </div>
          <div class="Organizer">
            <img src="img/fazlbarez.jpeg" alt="Fazl Barez" />
            <div>
              <h3><a href="https://fbarez.github.io/">Fazl Barez</a></h3>
              <p>Research fellow, University of Oxford</p>
            </div>
          </div>
          <div class="Organizer">
            <img src="https://homepages.inf.ed.ac.uk/scohen/ShayCohen2.jpg" alt="Shay B. Cohen" />
            <div>
              <h3><a href="https://homepages.inf.ed.ac.uk/scohen/">Shay B. Cohen</a></h3>
              <p>Reader, University of Edinburgh</p>
            </div>
          </div>
          <div class="Organizer">
            <img src="https://lena-voita.github.io/img/people/lena_blue.jpeg" alt="Elena Voita" />
            <div>
              <h3><a href="https://lena-voita.github.io/">Elena Voita</a></h3>
              <p>Research Scientist, Meta</p>
            </div>
          </div>
        </div>
      </section>
      <section>
        <h2>Correspondence</h2>
        Email: amiceli AT ed DOT ac DOT uk</p>
    </main>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/9.1.0/marked.min.js" integrity="sha512-4+zFvAejSGVlybiAKYyAz3KMjmbIT7I+wXgx190ZAsT19L2z8S4htBy1scR7CyP9pDKNSaolJMLedCigA/gFVg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
   <script>
     /**
 * drawdown.js
 * (c) Adam Leggett
 */

function markdown(src) {
  var rx_lt = /</g;
  var rx_gt = />/g;
  var rx_space = /\t|\r|\uf8ff/g;
  var rx_escape = /\\([\\\|`*_{}\[\]()#+\-~])/g;
  var rx_hr = /^([*\-=_] *){3,}$/gm;
  var rx_blockquote = /\n *&gt; *([^]*?)(?=(\n|$){2})/g;
  var rx_list =
    /\n( *)(?:[*\-+]|((\d+)|([a-z])|[A-Z])[.)]) +([^]*?)(?=(\n|$){2})/g;
  var rx_listjoin = /<\/(ol|ul)>\n\n<\1>/g;
  var rx_highlight =
    /(^|[^A-Za-z\d\\])(([*_])|(~)|(\^)|(--)|(\+\+)|`)(\2?)([^<]*?)\2\8(?!\2)(?=\W|_|$)/g;
  var rx_code = /\n((```|~~~).*\n?([^]*?)\n?\2|((    .*?\n)+))/g;
  var rx_link = /((!?)\[(.*?)\]\((.*?)( ".*")?\)|\\([\\`*_{}\[\]()#+\-.!~]))/g;
  var rx_table = /\n(( *\|.*?\| *\n)+)/g;
  var rx_thead = /^.*\n( *\|( *\:?-+\:?-+\:? *\|)* *\n|)/;
  var rx_row = /.*\n/g;
  var rx_cell = /\||(.*?[^\\])\|/g;
  var rx_heading = /(?=^|>|\n)([>\s]*?)(#{1,6}) (.*?)( #*)? *(?=\n|$)/g;
  var rx_para = /(?=^|>|\n)\s*\n+([^<]+?)\n+\s*(?=\n|<|$)/g;
  var rx_stash = /-\d+\uf8ff/g;

  function replace(rex, fn) {
    src = src.replace(rex, fn);
  }

  function element(tag, content) {
    return "<" + tag + ">" + content + "</" + tag + ">";
  }

  function blockquote(src) {
    return src.replace(rx_blockquote, function (all, content) {
      return element(
        "blockquote",
        blockquote(highlight(content.replace(/^ *&gt; */gm, "")))
      );
    });
  }

  function list(src) {
    return src.replace(rx_list, function (all, ind, ol, num, low, content) {
      var entry = element(
        "li",
        highlight(
          content
            .split(
              RegExp("\n ?" + ind + "(?:(?:\\d+|[a-zA-Z])[.)]|[*\\-+]) +", "g")
            )
            .map(list)
            .join("</li><li>")
        )
      );

      return (
        "\n" +
        (ol
          ? '<ol start="' +
            (num
              ? ol + '">'
              : parseInt(ol, 36) -
                9 +
                '" style="list-style-type:' +
                (low ? "low" : "upp") +
                'er-alpha">') +
            entry +
            "</ol>"
          : element("ul", entry))
      );
    });
  }

  function highlight(src) {
    return src.replace(
      rx_highlight,
      function (all, _, p1, emp, sub, sup, small, big, p2, content) {
        return (
          _ +
          element(
            emp
              ? p2
                ? "strong"
                : "em"
              : sub
              ? p2
                ? "s"
                : "sub"
              : sup
              ? "sup"
              : small
              ? "small"
              : big
              ? "big"
              : "code",
            highlight(content)
          )
        );
      }
    );
  }

  function unesc(str) {
    return str.replace(rx_escape, "$1");
  }

  var stash = [];
  var si = 0;

  src = "\n" + src + "\n";

  replace(rx_lt, "&lt;");
  replace(rx_gt, "&gt;");
  replace(rx_space, "  ");

  // blockquote
  src = blockquote(src);

  // horizontal rule
  replace(rx_hr, "<hr/>");

  // list
  src = list(src);
  replace(rx_listjoin, "");

  // code
  replace(rx_code, function (all, p1, p2, p3, p4) {
    stash[--si] = element(
      "pre",
      element("code", p3 || p4.replace(/^    /gm, ""))
    );
    return si + "\uf8ff";
  });

  // link or image
  replace(rx_link, function (all, p1, p2, p3, p4, p5, p6) {
    stash[--si] = p4
      ? p2
        ? '<img src="' + p4 + '" alt="' + p3 + '"/>'
        : '<a href="' + p4 + '">' + unesc(highlight(p3)) + "</a>"
      : p6;
    return si + "\uf8ff";
  });

  // table
  replace(rx_table, function (all, table) {
    var sep = table.match(rx_thead)[1];
    return (
      "\n" +
      element(
        "table",
        table.replace(rx_row, function (row, ri) {
          return row == sep
            ? ""
            : element(
                "tr",
                row.replace(rx_cell, function (all, cell, ci) {
                  return ci
                    ? element(
                        sep && !ri ? "th" : "td",
                        unesc(highlight(cell || ""))
                      )
                    : "";
                })
              );
        })
      )
    );
  });

  // heading
  replace(rx_heading, function (all, _, p1, p2) {
    return _ + element("h" + p1.length, unesc(highlight(p2)));
  });

  // paragraph
  replace(rx_para, function (all, content) {
    return element("p", unesc(highlight(content)));
  });

  // stash
  replace(rx_stash, function (all) {
    return stash[parseInt(all)];
  });

  return src.trim();
}

   </script>
    <script>
      document.addEventListener("DOMContentLoaded", function() {
    // Get all the sections with the class "markdown"
    let markdownSections = document.querySelectorAll('section.markdown');

    markdownSections.forEach(section => {
        // Convert markdown content to HTML
        let convertedHTML = markdown(section.textContent);
        
        // Replace section content with the converted HTML
        section.innerHTML = convertedHTML;
      console.log("Changed");
    });
});

    </script>
  </body>
</html>
